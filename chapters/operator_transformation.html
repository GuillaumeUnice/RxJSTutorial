<section>
    <h2>Transformation Operators part I</h2>
    <ul>
        <li>map</li>
        <br>
        <li style="color: red">mergeMap</li>
        <li style="color: red">concatMap</li>
        <li style="color: red">switchMap</li>
        <li style="color: red">exhaustMap</li>
        <br>
        <li>buffer</li>
        <li>bufferWhen</li>
        <li>bufferCount</li>
        <li>bufferTime</li>
        <li>bufferToggle</li>
    </ul>
</section>
<!-- <section>
    <h2>Observable as a Monad!</h2>
    <img src="images/nested_observable.png" width="400" style="border: none;" alt="Nested Observable schema" />
</section> -->
<section>
    <h2>MergeMap Operator</h2>
    <p style="font-size: 0.75em">Named flatMap Operator on RxJS > 5.X</p>
    <pre><code class="js"  data-trim contenteditable>
        const clicks$ = rxjs.fromEvent(document, 'click')
        clicks$.pipe(rxjs.operators.mergeMap((ev) => rxjs.interval(1000)))
    </code></pre>
    <iframe src="https://giphy.com/embed/uV6qjsjkzzcnoFQF1j" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using mergeAll</blockquote>
    <aside>
        On old article named flatMap()  (RxJS 4.X <=)
    </aside>
</section>
<section>
    <h2>concatMap Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                const clicks$ = rxjs.fromEvent(document, 'click')
                clicks$.pipe(rxjs.operators.concatMap(
                    (ev) => rxjs.interval(1000)
                        .pipe(rxjs.operators.take(5)))
                )
        </code></pre>
    <iframe src="https://giphy.com/embed/1UVCuNtFSGq3EqhPPz" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using concatAll</blockquote>
    <aside class="notes">
        - stock in a Buffer each Observable and play in order one after another
    </aside>
</section>
<section>
    <h2>switchMap</h2>
    <pre><code class="js"  data-trim contenteditable>
            const clicks$ = rxjs.fromEvent(document, 'click')
            clicks$.pipe(
                rxjs.operators.switchMap(
                    (ev) => rxjs.interval(1000).pipe(rxjs.operators.take(5))
                )
            )
    </code></pre>
    <iframe src="https://giphy.com/embed/5nsfoSeaaQ6xdJaQxN" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using switchAll || Map to observable, complete previous inner observable, emit values</blockquote>
</section>
<section>
    <h2>ExhaustMap Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                const clicks$ = rxjs.fromEvent(document, 'click')
                clicks$.pipe(rxjs.operators.exhaustMap(
                        (ev) => rxjs.interval(1000).pipe(rxjs.operators.take(5))
                    )
                )
        </code></pre>
    <iframe src="https://giphy.com/embed/NTgaF9Pv2JHqrnmrTg" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using exhaust || Map to inner observable,
        ignore other values until that observable completes</blockquote>
    <aside class="notes">
        - Like a concatMap which eliminate instead of stock in a Buffer each Observable. - Good solution to implement NGRX effects
        which prevent user trig new action before the first finished
    </aside>
</section>
<section>
    <h2>Other Transformation Operators</h2>
    <ul style="font-size: 0.75em">
        <li>pluck(...stringPropertyName) => Like map, but meant only for picking one of the nested properties of every emitted
            object
            <a href="//jsfiddle.net/Echyzen/kdhv2gpr/" target="_blank">here</a>
        </li>
        <li>mapTo(value) => Like map, but it maps every source value to the same output value every time
            <a href="//jsfiddle.net/Echyzen/7s9a81hf/" target="_blank">here</a>
        </li>
        <br>
        <li>expand => Recursively call provided function</li>
        <li>TODO: groupBy(selectorFunction) => groups the items emitted by an Observable according to a specified criterion, and emits
            these grouped items as GroupedObservables
            <a href="//jsfiddle.net/Echyzen/f4zypcqh/" target="_blank">here</a>
        </li>
        <li>partition(predicateFunction, thisArg) => It's like filter, but returns two Observables: one like the output of filter, and
            the other with values that did not pass the condition
            <a href="//jsfiddle.net/Echyzen/yLnhakqz/" target="_blank">here</a>
        </li>
    </ul>
</section>