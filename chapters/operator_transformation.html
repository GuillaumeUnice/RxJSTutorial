<section>
    <h2>Transformation Operators</h2>
    <ul>
        <li>map</li>
        <br>
        <li style="color: red">mergeMap</li>
        <li style="color: red">concatMap</li>
        <li style="color: red">switchMap</li>
        <li style="color: red">exhaustMap</li>
        <br>
        <li>buffer</li>
        <li>bufferWhen</li>
        <li>bufferCount</li>
        <li>bufferTime</li>
        <li>bufferToggle</li>
    </ul>
</section>
<!-- <section>
    <h2>Observable as a Monad!</h2>
    <img src="images/nested_observable.png" width="400" style="border: none;" alt="Nested Observable schema" />
</section> -->
<section>
    <h2>MergeMap Operator</h2>
    <p style="font-size: 0.75em">Named flatMap Operator on RxJS > 5.X</p>
    <pre><code class="js"  data-trim contenteditable>
        const clicks$ = Rx.Observable.fromEvent(document, 'click')
        clicks$.mergeMap((ev) => Rx.Observable.interval(1000))
    </code></pre>
    <iframe src="https://giphy.com/embed/uV6qjsjkzzcnoFQF1j" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using mergeAll</blockquote>
    <aside>
        On old article named flatMap()  (RxJS 4.X <=)
    </aside>
</section>
<section>
    <h2>concatMap Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                const clicks$ = Rx.Observable.fromEvent(document, 'click')
                clicks$.concatMap((ev) => Rx.Observable.interval(1000).take(5))
        </code></pre>
    <iframe src="https://giphy.com/embed/" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using concatAll</blockquote>
    <aside class="notes">
        - stock in a Buffer each Observable and play in order one after another
    </aside>
</section>
<section>
    <h2>switchMap</h2>
    <pre><code class="js"  data-trim contenteditable>
            const clicks$ = Rx.Observable.fromEvent(document, 'click')
            clicks$.switchMap((ev) => Rx.Observable.interval(1000).take(5))
    </code></pre>
    <iframe src="https://giphy.com/embed/5nsfoSeaaQ6xdJaQxN" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

    <blockquote>Map to observable, complete previous inner observable, emit values || Maps each value to an Observable, then flattens
        all of these inner Observables using switch</blockquote>
</section>
<section>
    <h2>ExhaustMap Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                const clicks$ = Rx.Observable.fromEvent(document, 'click')
                clicks$.exhaustMap((ev) => Rx.Observable.interval(1000).take(5))
        </code></pre>
    <iframe src="https://giphy.com/embed/NTgaF9Pv2JHqrnmrTg" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Maps each value to an Observable, then flattens all of these inner Observables using exhaust || Map to inner observable,
        ignore other values until that observable completes</blockquote>
    <aside class="notes">
        - Like a concatMap which eliminate instead of stock in a Buffer each Observable. - Good solution to implement NGRX effects
        which prevent user trig new action before the first finished
    </aside>
</section>
<section>
    <h2>Other Transformation Operators</h2>
    <ul style="font-size: 0.75em">
        <li>pairwise => Emit the previous and current values as an array
            <a href="//jsfiddle.net/btroncone/8va47bq3/" target="_blank">here</a>
        </li>
        <li>pluck(...stringPropertyName) => Like map, but meant only for picking one of the nested properties of every emitted
            object
            <a href="//jsfiddle.net/btroncone/n592m597/" target="_blank">here</a>
        </li>
        <li>mapTo(value) => Like map, but it maps every source value to the same output value every time
            <a href="//jsfiddle.net/btroncone/52fqL4nn/" target="_blank">here</a>
        </li>
        <br>
        <li>expand => Recursively call provided function</li>
        <li>groupBy(selectorFunction) => groups the items emitted by an Observable according to a specified criterion, and emits
            these grouped items as GroupedObservables
            <a href="//jsfiddle.net/btroncone/utncxxvf/" target="_blank">here</a>
        </li>
        <li>partition(predicateFunction) => It's like filter, but returns two Observables: one like the output of filter, and
            the other with values that did not pass the condition
            <a href="//jsfiddle.net/btroncone/q0xo7gvv/" target="_blank">here</a>
        </li>
        <br>
        <li>window(predicateObservable) => It's like buffer, but emits a nested Observable instead of an array </li>
        <li>windowCount(number) => It's like bufferCount, but emits a nested Observable instead of an array</li>
        <li>windowToggle() => It's like bufferToggle, but emits a nested Observable instead of an array</li>
        <li>windowTime(periodNumber) => It's like bufferTime, but emits a nested Observable instead of an array</li>
        <li>windowWhen(predicateFunction) => It's like bufferWhen, but emits a nested Observable instead of an array</li>
    </ul>
    <aside class="notes">
        - pairwise: Pretty much like Buffer
    </aside>
</section>