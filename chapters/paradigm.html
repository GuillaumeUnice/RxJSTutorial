<section>
    <h2>What &amp; Why</h2>
    <blockquote>
        A library to streamline (no pun intented) our code through an Unidirectional Data Flow based on Functional Reactive Programming
        (aka FRP) &amp; OOP Observer and Iterator Design Pattern.

    </blockquote>
    <p>
        Introduce a new <strong>Asynchronous Structure</strong> concerning the code, but also the Error-Handling
        <br> => The chief goal consist to make it easier the composition of asynchronous code
    </p>
</section>
<section>
    <h2>Paradigm Tree!</h2>
    <img src="images/paradigm.png" style="border: none;" alt="schema show different programming paradigm family" />
</section>
<section>
    <h2>JavaScript Multi-Paradigm or Zero-Paradigm?</h2>
    <blockquote style="line-height: 2em">
        Natural language has no dominant paradigm, and neither does JavaScript. Developers can select from a grab bag of approaches procedural, functional, and object-oriented and blend them as appropriate
     <span  style="position: absolute; right: 0; bottom: -20px; font-size: 0.5em">Angus Croll, If Hemingway Wrote JavaScript</span>
    </blockquote>
</section>
<section>
    <h2>Appendix side-effect</h2>
    <img src="images/side_effect.png" style="border: none;" alt="Simple example of a side-effect" />
    <p>Side-effects concern function which update/use:</p>
    <ul>
        <li>Global or Static variable</li>
        <li>Update argument</li>
        <li>Write/Read data from/to file, database, call API</li>
    </ul>
</section>
<section>
    <h2>Declarative vs Imperative</h2>
    <img src="images/declarative_example.png" style="border: none;" alt="Example between declarative and imperative mindset"
    />
    <p>
        Applying these functions declaratively meaning your code expresses the
        <strong>what</strong> and not the
        <strong>how</strong> of what you’re trying to accomplish
    </p>
    <aside class="notes">
        -Concretly How we are more close with the computer science implementation and problematic
        -Wheras What mathematical way
        => Nowadays, possible thanks to performance improvment (hardware limitation, latency) but also concept introduction (memoization, Immutable Data Structure)
	</aside>
</section>
<section>
    <h2>RxJS Principles &amp; Mindset</h2>
    <ul>
        <!-- Flatten Development =>more concise, readable, understandable | Unit code is the function not a stateful class | leverage us in more mathematical mindset without Computer Science problematic memory and so on-->
        <li>FP (Higher-Order Function, Pure Function, Immutability, Functor, Lazyness)</li>
        <li>Unifying Computing Model (Observable Operator)</li>
        <!--RxJS allows you to build logic independently of the type of data source you need to interact with-->
        <li>OOP (Iterator Pattern + Observer Pattern)</li>
        <li>Streamline Memory Handling (less Memory Leak)</li>
        <li>
            <a href="//www.reactivemanifesto.org/" target="_blank">Reactive Manifesto</a>
        </li>
    </ul>
</section>
<section>
    <h2>Functional Programming Principles &amp; Mindset</h2>
    <img src="images/functional_programming.png" style="border: none;" alt="functional programming listed principle" />
    <aside class="notes">
        1- First-Class Function: Function like Object (assignable inside in a variable)
        2- Higher Order Function: function's parameter and return (that's why callback are available)
        3- Immutable Data: Only primitive variable by defaut => We have to erase each variable
        4- Recursion: call same function => tail recursion optimisation TODO: see Graf article
        consist to replace a stack empilement call par un simple appelle fonction
        Ainsi le compilateur est capable de le transformer en iteratif en réappelant et écrasant la même fonction juste modifiant les arguments

        Pour cela utiliser un accumulteur et retourner seulement la fonction ou l'accumulteur pour la condition de sortie.

        const fact = (n) => {
            if(n == 0) return 1
            return n*fact(n-1)
        }
        ///////////////////////////////////////////////////////////
        const fact = (n) => {
            const factIntern = (n, acc) => {
                if(n > 0) return fact(n-1, n*acc)
                else return acc
            }
            return factIntern(n, 1)
        }

        const fib = (n) => {
            if(n <= 1) return 1
            return fib(n-1) + fib(n-2)
        }
        ///////////////////////////////////////////////////////////////////
        const fib = (n, a = 1, b = 0) => {
            if(n === 0) return a
            return fib(n-1, a+b, a)
        }

        5- Functor: Data type which can project a function inside each element in a specific context by flattening this context
        6- Lazy Evaluation: compute code at last time need to be print => reason on infite set apply set theory thinking
        7-Pure function: deterministic (same I => same O) => Function without random or other side-effect outside
        8- Monad: Data type which can flatten before project a function inside each element in a specific context double flattening
	</aside>
</section>
<section>
    <h2>Reactive Programming Principles &amp; Mindset</h2>
    <!--Thinking Reactively-->
    <img src="images/reactive_programming.png" width="400" style="border: none;" alt="Excel example to demonstrate reactive programming mindset"
    />
    <!-- Certainly, asynchronous functions allow us to stay responsive, but they come at a price. Where synchronous programs
    allow us to reason directly about the state of the application, asynchronous code forces us to reason about its future
    state. -->
    <pre><code class="js"  data-trim contenteditable>
        stream1$ = [1];
        stream2$ = [2];
        streamAdd$ = stream1$.concat(stream2$).reduce(sum); // => 3
        stream1$.push(10);
        // What's going on? Concerning streamAdd$???
    </code></pre>
</section>
<section>
    <h2>FP + RP = FRP!</h2>
    <blockquote>
        A stream is FRP => FP with steroids!!!
    </blockquote>
    <aside class="notes">
        -FRP control reactivity power
        -parallal 90's OOP vs procedural
	</aside>
</section>
<section>
    <h2>Current common Type solution</h2>
    <table>
        <thead>
            <tr style="color: rgb(233, 70, 70)">
                <th></th>
                <th>Single Value</th>
                <th>Multiple Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="color: rgb(70, 81, 233)">Synchronous</td>
                <td>Char - Boolean - Number</td>
                <td>String - Array - Map</td>
            </tr>
            <tr>
                <td style="color: rgb(70, 81, 233)">Asynchronous</td>
                <td>Promise</td>
                <td>Event Emitter - DOM Event</td>
            </tr>
        </tbody>
    </table>

    <aside class="notes">
        -Synchronous step-by-step
        -Asynchronous thinking about future and callback
	</aside>
</section>
<section>
        <h2>"Once upon a time... Asynchronous"</h2>
</section>
<section>
    <h2>Asynchronous emphasis</h2>
    <!-- Synchronous code is a step-by-step sequential execution of statements where each step depends on the previous one to run.
        VS Callback functions in JavaScript create an inversion of control where functions call the application back, instead
        of the other way around.
        // Arrow function
        think about futur state everytime everywhere -->
    <img src="images/event_loop.jpg" width="400" style="border: none;" alt="JS Event-Loop schema" />
    <p>JavaScript Event-Loop:
        <a href="//latentflip.com/loupe/" target="_blank">Here</a>
    </p>
    <p><a href="//www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank">Video</a></p>

    <aside class="notes">
        -JS monothreaded event-loop => each operation delegate to thread system #webAPI
        => result come back callback queue
	</aside>
</section>
<section>
        <h2>"Fin"</h2>
</section>
<section>
    <h2>Callback</h2>
    <pre><code class="js" data-trim contenteditable>
            getData(function(a){
                getMoreData(a, function(b){
                    getMoreMoreData(b, function(c){
                        getMoreMoreMoreData(c, function(d){
                            getMoreMoreMoreMoreData(d, function(e){
                                // and so on...
                            });
                        });
                    });
                });
            });
        </code></pre>
    <blockquote>Horizontally nested calls => "Callback Hell"</blockquote>
    <aside class="notes">
        -Inversion of Controle
        -BUT Callback Hell
	</aside>
</section>

<!-- <section>
        Mix: Imperative (for loop) + asynchonous = bug => flat that with Functor no loop anymore Functions that terminate at unpredictable
        times are typically harder to deal with without the proper methods and practices. When this happens, the mental model
        of our application needs to shift to compensate for this additional dimension. => side effect solution => pure function
        (from FP)
    </section> -->

<section>
    <h4>Promises (FP principle)</h4>
    <!-- Promise s to represent any asynchronous computation that’s expected to complete in the future With Promise s, you can chain
        together a set of actions with future values to form a continuation. 2 A continuation is just a fancy term for writing
        callbacks and has a lot to do with the principle of Inversion of Control we referenced earlier. A continuation (a
        callback) allows the function to decide what it should do next, instead of indiscriminately wait- ing for a return
        value. They’re used heavily when iterating over arrays, tree structures, try/catch blocks, and, of course, asynchronous
        programming. A Promise is a data type that wraps an asynchronous or long-running operation, a future value, with
        the ability for you to subscribe to its result or its error. Promise s create a flow of calls chained by then methods.
        If the Promise is fulfilled, the chain of functions continues; otherwise, the error is delegated to the Promise catch
        block. CF figure 1.7 -->

    <pre><code class="js" data-trim contenteditable>
            // Callback
            step1(value, function(data){
                step2(data, function(data2){
                    step3(data2, function(data3){
                    step4(data3, function(data4){
                        //INSTRUCTIONS ...
                    });
                    });
                });
            });

            // Promise
            step1.then(step2).then(step3).then(step4)
        </code></pre>
    <img src="images/promise_schema.png" width="400" style="border: none;" alt="Promise schema" />
    <blockquote>Promise returns an immutable, <span style="color: red">single postponed</span> cached value</blockquote>
    <aside class="notes">
        -New ES6 standard Promise => Functor even Monad like Haskell's Maybe | Java's Optionnal
        -Syntaxic sugar really important chained future result => just subscribe to an .then() .catch() to manage all the stuff
	</aside>
</section>

<section>
    <h4>Promise drawbacks!</h4>
     <ul>
        <li>Manage only one value (not like mouse event or sequence of bytes in a file stream => no repeatable/retriable)</li>
        <li>Once run/trig couldn't be cancelled</li>
    </ul>
    <!-- But what you really need is a solution that abstracts out the notion of latency away from your code while allowing you to
        model your solutions using a linear sequence of steps through which data can flow over time -->
        <aside class="notes">
            -Guaranteed Future (=> No Cancellation)
            -Single Value (=> Only Ajax purpose)
            => No WS, DOM data event managed
            => We have to find a way in order to manage a stream of data.
        </aside>
    </section>
</section>

<!-- <section>
    <h4>Mutliple data in a synchrounous way RP</h4>
    Usual solution Event Emitter (like NodeJS or Forms :D) CF figure 1.6 composing nested asynchronous flow = problem => need
    an additional lifted level of abstraction
</section> -->
<section>
    <h2>Don't worry stream is beautiful!</h2>
    <p style="font-size: 0.5em;">We have to shift our mindset to think in terms of streams, also known as functional sequences of events. RxJS implements
        under the hood through the use of familiar patterns such as Iterator and Observer.</p>
    <table>
        <thead>
            <tr style="color: rgb(233, 70, 70)">
                <th></th>
                <th>Single Value</th>
                <th>Multiple Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="color: rgb(70, 81, 233)">Synchronous</td>
                <td>Observable</td>
                <td>Observable</td>
            </tr>
            <tr>
                <td style="color: rgb(70, 81, 233)">Asynchronous</td>
                <td>Observable</td>
                <td>Observable</td>
            </tr>
        </tbody>
    </table>
    <!-- <p>DOC: Emitted, Static &amp; Generated Data => page 44</p> -->
    <img src="images/stream.jpeg" width="350" style="border: none;" alt="Everything is a Stream meme" />
    <aside class="notes">
        -uniformise data representation => FP + OOP DP Observer &amp; DP
    </aside>
</section>

<section>
    <h2>OOP DP</h2>
    <p>Two Behaviour DPs: Observer &amp; Iterator</p>
</section>
<section>
    <h2>Observer</h2>

    <img src="images/observer_uml.png" style="border: none;" alt="Observer UML Diagram" />
    <p>
        <a href="//jsfiddle.net/Echyzen/2xk3o92x/11/" target="_blank">Here</a>
    </p>

</section>
<section>
    <h2>Iterator</h2>
    <!-- DOC:
        https://addyosmani.com/resources/essentialjsdesignpatterns/book/#iteratorpatternjquery
        http://www.dofactory.com/javascript/iterator-design-pattern
        https://scotch.io/bar-talk/4-javascript-design-patterns-you-should-know#observer-design-pattern
        https://sourcemaking.com/design_patterns/iterator
    -->
    <img src="images/iterator_uml.png" style="border: none;" alt="Iterator UML Diagram" />
    <p>
        <a href="//jsfiddle.net/MrPolywhirl/7rmrxu33/" target="_blank">Here</a>
    </p>

</section>