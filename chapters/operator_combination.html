<section>
    <h2>Combination Operators I</h2>
    <ul style="font-size: 0.75em">
        <li style="color: red">merge => Interleave events by merging streams</li>
        <li style="color: red">concat => Preserve order of events by concatenating streams</li>
        <li style="color: red">switchAll => Switch to the latest stream data</li>
        <br>
        <li>mergeAll</li>
        <li>concatAll</li>
        <li>zipAll</li>
        <br>
        <li>combineLatest</li>
        <li>forkJoin</li>
        <li>zip</li>
        <li>withLatestFrom</li>
        <br>
        <li>exhaust</li>
        <li>combineAll</li>
        <li>race</li>
        <li>startWith</li>
    </ul>
</section>
<section>
    <h2>Merge Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
            // Synchronous behaviour
            const stream1$ = rxjs.of('a', 'b', 'c')
            const stream2$ = rxjs.of(1, 2, 3)
            // equivalent [Static|Observable] method: rxjs.merge(stream1$, stream2$)
            stream1$.pipe(rxjs.operators.merge(stream2$))
    </code></pre>
    <img src="images/merge_synchronous.png" width="400" style="border: none;" alt="Merge Operator with synchronous data Marble Diagram"
    />
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        const clicks$ = rxjs.fromEvent(document, 'click')
            .pipe(rxjs.operators.map((ev) => ev.clientX))
        const timer$ = rxjs.interval(1000)
        // equivalent [Static|Observable] method: rxjs.merge(clicks$, timer$)
        clicks$.pipe(rxjs.operators.merge(timer$))
    </code></pre>
    <iframe src="https://giphy.com/embed/l70a0u7fTI7Lri0x5a" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Flattens multiple Observables together by blending their values into one Observable</blockquote>
</section>
<section>
    <h2>Concat Operator</h2>
    <pre style="font-size: 0.5em; margin: 0"><code class="js"  data-trim contenteditable>
            const stream1$ = rxjs.of('a', 'b', 'c').pipe(rxjs.operators.delay(3000))
            const stream2$ = rxjs.of(1, 2, 3)
            // equivalent [Static|Observable] method: rxjs.concat(stream1$, stream2$)
            stream1$.pipe(rxjs.operators.concat(stream2$))
        </code></pre>
    <iframe src="https://giphy.com/embed/9RXQODno83AQuGZNGg" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <pre style="font-size: 0.5em; margin: 0"><code class="js"  data-trim contenteditable>
                rxjs.concat(
                    rxjs.interval(1000),
                    rxjs.of('This', 'Never', 'Runs')
                )
                // When source never completes, the subsequent observables never runs
                // Warning: Here the second Observable is actually HOT for asynchronous data type
            </code></pre>
    <iframe src="https://giphy.com/embed/1AevzIEuTaCZaNqdqt" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other</blockquote>
</section>
<section>
    <h2>switchAll Operator</h2>
    <pre style="font-size: 0.5em; margin: 0"><code class="js"  data-trim contenteditable>
        const stream1$ = rxjs.of('a', 'b', 'c')
            .pipe(rxjs.operators.delay(3000))
        const stream2$ = rxjs.of(1, 2, 3)
        stream1$.pipe(rxjs.operators.switchAll(stream2$))
    </code></pre>
    <iframe src="https://giphy.com/embed/3j4IidvNsiFHoorNVc" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

    <pre style="font-size: 0.5em; margin: 0"><code class="js"  data-trim contenteditable>
        const clicks$ = rxjs.fromEvent(document, 'click')
            .pipe(rxjs.operators.map((ev) => rxjs.interval(1000)))
        clicks$.pipe(rxjs.operators.switchAll())
    </code></pre>
    <iframe src="https://giphy.com/embed/1YbvP2jVibyMNYKeaQ" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Flattens an Observable-of-Observables by dropping the previous inner Observable once a new one appears</blockquote>
    <aside class="notes">
        -So far, it behaves like mergeAll. However, when a new inner Observable is emitted, switch unsubscribes from the earlier-emitted inner Observable
            and subscribes to the new inner Observable and begins emitting items from it. It continues to behave like this for subsequent inner Observables.
        - Such as cancelling the first sequence when a new one begins emitting
        -Actually this Operator could appear really tricky it's chiefly due to the fact we don't stud inner Observable and higher-oder Observable but don't want to bother you about that yet
    </aside>
</section>
<section>
    <h2>Exercice</h2>
    <ul>
        <li>Implement a search bar</li>
        <p>
            <a href="//jsfiddle.net/Echyzen/jrvqoL9s/" target="_blank">here</a>
        </p>
    <!--
        'https://en.wikipedia.org/w/api.php?action=query&format=json&list=search&utf8=1&srsearch=lol
    Exercice: Realize a search bar with a map projection (afterthat replace with a switchMap)
    const search$ = Rx.Observable.fromEvent(inputText, 'keyup')
        .pluck('target', 'value')
        .debounceTime(1000)
        .do(query => console.log(`Querying for ${query}...`))
        .map(query => sendRequest(testData, query)))
        .subscribe(...)
    -->
    <aside class="notes">
        <a href="//jsfiddle.net/vbqgLk6y/" target="_blank">Here</a>
    </aside>
    </ul>
</section>