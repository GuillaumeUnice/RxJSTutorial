<section>
    <h2>Combination Operators I</h2>
    <ul style="font-size: 0.75em">
        <li style="color: red">merge => Interleave events by merging streams</li>
        <li style="color: red">concat => Preserve order of events by concatenating streams</li>
        <li style="color: red">switchAll => Switch to the latest stream data</li>
        <br>
        <li>mergeAll</li>
        <li>concatAll</li>
        <li>zipAll</li>
        <br>
        <li>combineLatest</li>
        <li>forkJoin</li>
        <li>zip</li>
        <li>withLatestFrom</li>
        <br>
        <li>exhaust</li>
        <li>combineAll</li>
        <li>race</li>
        <li>startWith</li>
    </ul>
</section>
<section>
    <h2>Merge Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
            // Synchronous behaviour
            const stream1$ = Rx.Observable.of('a', 'b', 'c')
            const stream2$ = Rx.Observable.of(1, 2, 3)
            stream1$.merge(stream2$) // equivalent [Static|Observable] method: Rx.Observable.merge(stream1$, stream2$)
    </code></pre>
    <img src="images/merge_synchronous.png" width="400" style="border: none;" alt="Merge Operator with synchronous data Marble Diagram"
    />
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        const clicks$ = Rx.Observable.fromEvent(document, 'click')
            .map((ev) => ev.clientX)
        const timer$ = Rx.Observable.interval(1000)

        clicks$.merge(timer$) // equivalent [Static|Observable] method: Rx.Observable.merge(clicks$, timer$)
    </code></pre>
    <iframe src="https://giphy.com/embed/l70a0u7fTI7Lri0x5a" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Flattens multiple Observables together by blending their values into one Observable</blockquote>
</section>
<section>
    <h2>Concat Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
            const stream1$ = Rx.Observable.of('a', 'b', 'c').delay(3000)
            const stream2$ = Rx.Observable.of(1, 2, 3)
            stream1$.concat(stream2$) // equivalent [Static|Observable] method: Rx.Observable.concat(stream1$, stream2$)
        </code></pre>
    <iframe src="https://giphy.com/embed/9RXQODno83AQuGZNGg" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
                Rx.Observable.concat(Rx.Observable.interval(1000),
                Rx.Observable.of('This', 'Never', 'Runs'))
                // When source never completes, the subsequent observables never runs
                // Warning: Here the second Observable is actually HOT for asynchronous data type
            </code></pre>
    <iframe src="https://giphy.com/embed/1AevzIEuTaCZaNqdqt" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other</blockquote>
</section>
<section>
    <h2>switchAll Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        const stream1$ = rxjs.of('a', 'b', 'c')
            .pipe(rxjs.operators.delay(3000))
        const stream2$ = rxjs.of(1, 2, 3)
        stream1$.pipe(rxjs.operators.switch(stream2$))
    </code></pre>
    <iframe src="https://giphy.com/embed/3j4IidvNsiFHoorNVc" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        const clicks$ = Rx.Observable.fromEvent(document, 'click')
            .map((ev) => Rx.Observable.interval(1000))
        clicks$.switch()
    </code></pre>
    <iframe src="https://giphy.com/embed/1YbvP2jVibyMNYKeaQ" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <p>Flattens an Observable-of-Observables by dropping the previous inner Observable once a new one appears</p>
    <blockquote></blockquote>
    <aside class="notes">
        -So far, it behaves like mergeAll. However, when a new inner Observable is emitted, switch unsubscribes from the earlier-emitted inner Observable
            and subscribes to the new inner Observable and begins emitting items from it. It continues to behave like this for subsequent inner Observables.
        - Such as cancelling the first sequence when a new one begins emitting
        -Actually this Operator could appear really tricky it's chiefly due to the fact we don't stud inner Observable and higher-oder Observable but don't want to bother you about that yet
    </aside>
</section>
<section>
    <h2>Exercice</h2>
    <ul>
        <li>Implement a search bar</li>
    <!--
        'https://en.wikipedia.org/w/api.php?action=query&format=json&list=search&utf8=1&srsearch=lol
    Exercice: Realize a search bar with a map projection (afterthat replace with a switchMap)
    const search$ = Rx.Observable.fromEvent(inputText, 'keyup')
        .pluck('target', 'value')
        .debounceTime(1000)
        .do(query => console.log(`Querying for ${query}...`))
        .map(query => sendRequest(testData, query)))
        .subscribe(...)
    -->
    </ul>
</section>