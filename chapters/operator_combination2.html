<section>
    <h2>Combination Operators II</h2>
    <ul style="font-size: 0.75em">
        <li>merge</li>
        <li>concat</li>
        <li>switchAll</li>
        <br>
        <li>mergeAll</li>
        <li>concatAll</li>
        <li>zipAll</li>
        <br>
        <li style="color: red">combineLatest</li>
        <li style="color: red">forkJoin</li>
        <li style="color: red">zip</li>
        <li style="color: red">withLatestFrom</li>
        <br>
        <li style="color: red">exhaust</li>
        <li style="color: red">combineAll</li>
        <li style="color: red">race</li>
        <li style="color: red">startWith</li>
    </ul>
</section>

<section>
    <h2>combineLatest Operator</h2>
    <pre style="font-size: 0.5em; margin: 0"><code class="js"  data-trim contenteditable>
        // synchronous behaviour
        const s1$ = rxjs.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
        const s2$ = rxjs.of('a', 'b', 'c', 'd', 'e');
        rxjs.combineLatest(s1$, s2$)
            .pipe(rxjs.operators.delay(3000))
    </code></pre>
    <iframe src="https://giphy.com/embed/2aFWTnkJrWLELrwdTs" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <pre style="font-size: 0.5em; margin: 0"><code class="js"  data-trim contenteditable>
        // Asynchronous behaviour
        const interval$ = rxjs.interval(1000)
        rxjs.combineLatest(interval$, interval$.pipe(rxjs.operators.take(2)))
    </code></pre>
    <iframe src="https://giphy.com/embed/3ktUmNNScuB5p1M5WY" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Whenever any input Observable emits a value, it computes a formula using the latest values from all the inputs, then emits the output of that formula || When any observable emits a value, emit the latest value from each</blockquote>
</section>
<section>
    <h2>forkJoin Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        rxjs.forkJoin(
            rxjs.of('Hello'),   // emit 'Hello' immediately
            rxjs.of('World').pipe(rxjs.operators.delay(1000)), // emit 'World' after 1 second
            rxjs.interval(1000).pipe(rxjs.operators.take(1)), // emit 0 after 1 second
            rxjs.interval(1000).pipe(rxjs.operators.take(2)) //emit 0...1 in 1 second interval
          )
    </code></pre>
    <iframe src="https://giphy.com/embed/8Ffuwbei2F2HE7G9nd" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <p>Pretty much like a Promise.all() but for stream so just keep last value before strem completion
        <a href="//jsfiddle.net/Echyzen/L8ujp6xr/"
            target="_blank">here</a>
    </p>
    <blockquote>Wait for Observables to complete and then combine last values they emitted || When all observables complete, emit the
        last emitted value from each</blockquote>
</section>
<section>
    <h2>zip Operator</h2>
    <!-- like combineLatest() , except that the former matches the index of the corresponding events one-to-one

    Example with synchronous data:
    const s1$ = Rx.Observable.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
const s2$ = Rx.Observable.of('a', 'b', 'c', 'd', 'e');
Rx.Observable.zip(s1$, s2$).subscribe(console.log);
//-> [1, "a"]
[2, "b"]
[3, "c"]
[4, "d"]
[5, "e"]
203
Rx.Observable.combineLatest(s1$, s2$).subscribe(console.log);
//-> [9, "a"]
[9, "b"]
[9, "c"]
[9, "d"]
[9, "e"]

The zip() operator can be very useful in cases when you need to spread out a stream synchronously over time. We'll see that next with retry backoff strategy implementation
    -->
    <pre style="font-size: 0.45em; margin: 0;"><code class="js"  data-trim contenteditable>
        const interval$ = rxjs.interval(1000)
        //when one observable completes no more values will be emitted
        rxjs.zip(interval$, interval$.pipe(rxjs.operators.take(2)))
    </code></pre>
    <iframe src="https://giphy.com/embed/p3UpBnlcSest8ApaFW" width="300" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <!-- <pre style="font-size: 0.45em; margin: 0;"><code class="js"  data-trim contenteditable>
            const age$ = rxjs.of(27, 25, 29)
            const name$ = rxjs.of('Foo', 'Bar', 'Beer')
            const isDev$ = rxjs.of(true, true, false)
            // Here we compute the created value through a function in last parameter
            rxjs.of(age$, name$, isDev$)
                .pipe(
                    rxjs.operators.zipAll((age, name, isDev) => ({ age, name, isDev })),
                    rxjs.operators.delay(3000)
                )
        </code></pre>
    <iframe src="https://giphy.com/embed/NS69RN2zKkGTwpYFvS" width="300" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote style="font-size: 0.75em">
        Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables
    </blockquote>
</section>
<aside class="notes">
    Pretty much like zip Operator but on Observable of Observable so only intance method
</aside> -->
</section>
<section>
    <!-- Exercice explain: withLatestFrom => //jsfiddle.net/btroncone/0dLeksLe/ -->
    <h2>withLatestFrom Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        const source$ = rxjs.interval(2000) // emit every 2s
        const secondSource$ = rxjs.interval(500) // emit every 0.5s
        source$.pipe(
            rxjs.operators.withLatestFrom(secondSource$),
            map(([first, second]) => `First Source (5s): ${first} Second Source (1s): ${second}`)
        )
        </code></pre>
    <iframe src="https://giphy.com/embed/2aFfVNhX8jkTHQA2Qq" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Whenever the source Observable emits a value, it computes a formula using that value plus the latest values from other input Observables, then emits the output of that formula || Also provide the last value from other observables</blockquote>
</section>
<section>
    <h2>exhaust Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
        const clicks$ = Rx.Observable.fromEvent(document, 'click')
        const higherOrder$ = clicks.map((ev) => Rx.Observable.interval(1000).take(5))
        higherOrder$.exhaust()
    </code></pre>
    <iframe src="https://giphy.com/embed/NTgaF9Pv2JHqrnmrTg" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Flattens an Observable-of-Observables by dropping the next inner Observables while the current inner is still executing</blockquote>
</section>
<section>
    <h2>Other Combination Operators</h2>
    <ul>
        <li>combineAll => Flattens an Observable-of-Observables by applying combineLatest when the Observable-of-Observables completes <a href="//jsfiddle.net/btroncone/pvj1nbLa/" target="_blank">here</a></li>
        <li>race => The observable to emit first is used <a href="//jsfiddle.net/btroncone/8jcmb1ec/" target="_blank">here</a></li>
        <li>startWith => Emit given value first  <a href="//jsfiddle.net/btroncone/ckcyj3ms/" target="_blank">here</a></li>
    </ul>
    <aside class="notes">
        - combineAll => Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the combineLatest strategy <a href="//reactivex.io/rxjs/class/es6/Observable.js~Observable.html#instance-method-combineAll" target="_blank">diagram</a>
        - race => Returns an Observable that mirrors the first source Observable to emit an item from the combination of this Observable and supplied Observables
        - startWith => Returns an Observable that emits the items you specify as arguments before it begins to emit items emitted by the source Observable
    </aside>
</section>