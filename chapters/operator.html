<section>
    <h3>Operator type</h3>
    <ul>
        <li>Creator Operator</li>
        <!--*-->
        <li>Transforming Operator</li>
        <li>Filtering Operator</li>
        <li>Combining Operator</li>
        <!--*-->
        <li>Conditional &amp Boolean Operator</li>
        <li>Mathematical &amp Aggregate Operator</li>
        <li>Error Handling Operator</li>
        <!--*-->
        <li>Utility/Tool Operator (like do() or tap())</li>
        <li>Multicasting Operator</li>
    </ul>
    <aside class="notes">
        -source Observable => emit Observable (higher-order function) -no mute current Observable but do something on value inside
        an Observable context => Functor -Even inside an Observable of Observable => Monad
    </aside>
</section>
<section>
    <h3>Operator Optimization</h3>

    <aside class="notes">
        - Same data reference through Observables => not like plain vanilla Array prototype method - New set of data each Observer
        Subscription
    </aside>
</section>
<section>
    <h2>Static|Observable methods / Observable factory
        <br>VS
        <br> Instance methods / Observable instance methods</h2>
    <ul>
        <li>Static => Initiate Producer (Creator &amp; Combination Operator)</li>
        <li>Instance => Pipeline Operation</li>
    </ul>
    <aside class="notes">
        - Static directly define inside Rx.Observable Object - Instance method define inside Observable prototype chain.
    </aside>
</section>
<section>
    <h2>Core/Common/Main Operator</h2>
    <ul>
        <li>map</li>
        <li>filter</li>
        <li>reduce (scan)</li>
    </ul>
</section>

<section>
    <h2>Map Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
            Rx.Observable.fromEvent(document, 'click')
            .map(ev => ev.clientX)
        </code></pre>
    <iframe src="https://giphy.com/embed/7SHwcdWKQGHQqpElbv" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>

    <blockquote>It passes each source value through a transformation function to get corresponding output values</blockquote>
    <aside class="notes">
        Applies a given project function to each value emitted by the source Observable, and emits the resulting values as an Observable
    </aside>
</section>

<section>
    <h2>Filter Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
            Rx.Observable.timer(0, 1000)
            .filter(x => x % 2 === 0)
        </code></pre>
    <iframe src="https://giphy.com/embed/fQPSQ6Va1v9kmstsnb" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>It only emits a value from the source if it passes a criterion function</blockquote>
    <aside class="notes">
        Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate
    </aside>
</section>
<section>
    <h2>Reduce Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                Rx.Observable.timer(0, 1000)
                .take(6)
              .reduce((acc, cur) => acc += cur, 0)
            </code></pre>
    <iframe src="https://giphy.com/embed/RI4JxoQzejbhANMYqi" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <iframe src="https://giphy.com/embed/pzr4yV0NrCGvLE6cb4" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>
        Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value
        into the accumulation from the past
    </blockquote>
    <aside class="notes">
        Applies an accumulator function over the source Observable, and returns the accumulated result when the source completes,
        given an optional seed value
    </aside>
</section>
<section>
    <h2>Scan Operators</h2>
    <iframe src="https://giphy.com/embed/pVUSiUQ2wzFn28OSBl" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>It's like reduce, but emits the current accumulation whenever the source emits a value</blockquote>
    <aside class="notes">
        Applies an accumulator function over the source Observable, and returns each intermediate result, with an optional seed value
    </aside>
</section>
<section>
    <h2>Exercice</h2>
    <ul>
        <li>Count the number of 'T' character from a text</li> <!-- //jsfiddle.net/Echyzen/7jmh0nc3/ http://mabboux.pagesperso-orange.fr/informatique/haskell/haskellaturoff.html -->
        <li>Get the most used character</li> <!-- https://jsfiddle.net/qejzte93/-->
    </ul>
    <aside class="notes">
        - Make this exercice is easy because one big part of the exercice is already done
        <br>
        => formulate "WHAT" we want in a soft programming
        <br><br>
        Nevertheless, we have to do that shift by yourself so try your hand is essential to be used to adopt this approach
        <br><br>
        Count the number of 'T' => //jsfiddle.net/Echyzen/7jmh0nc3/
        <br>
        Get the most used character => https://jsfiddle.net/qejzte93/
    </aside>
</section>
