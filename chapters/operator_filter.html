<section>
    <h2>Filtering Operators</h2>
    <ul>
        <li>filter</li>
        <br>
        <li>delay</li>
        <li>debounceTime - debounce</li>
        <li>throttleTime - throttle</li>
        <br>
        <li>distinct - distinctUntilChanged</li>
        <br>
        <li>take - takeLast - takeUntil - takeWhile</li>
    </ul>
</section>
<section>
    <h2>Time as a filter predicate</h2>
    <ul>
        <li>Explicit time: relative time &amp; absolute time</li>
        <li>Implicit time</li>
    </ul>
    <aside class="notes">
            You can think of this operator as belonging to the filtering category of operators, using time as the predicate to decide which events to keep.
            <br>
            #DEBOUNCE In simple software terms, debouncing means “execute a function or some action only if a certain period has passed without it being called.”
    </aside>
</section>
<section>
    <h2>Delay Operator</h2>

    <pre><code class="js"  data-trim contenteditable>
        rxjs.of([1, 2, 3, 4, 5])
            .pipe(
                rxjs.operators.tap(x => console.log(`Emitted: ${x}`)),
                rxjs.operators.delay(200)
            )

        rxjs.from([1, 2])
            .pipe(
                rxjs.operators.delay(2000),
                rxjs.operators.concat(rxjs.from([3, 4])),
                rxjs.operators.delay(2000),
                rxjs.operators.concat(rxjs.from([5, 6])),
                rxjs.operators.delay(2000)
            )
    </code></pre>
    <ul>
        <li>Use a Buffer internally</li>
        <li>Apply only on event one by one</li>
    </ul>
</section>
<section>
    <h2>DebounceTime Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                rxjs.of(1, 10)
                    .pipe(rxjs.operators.debounceTime(2000))
                // Synchronous values with a complete() signal event bring about receive immediately the last event
        </code></pre>
    <img src="images/debounceTime.png" width="400" style="border: none;" alt="DebounceTime synchronous value marble diagram"
    />
    <pre><code class="js"  data-trim contenteditable>
            rxjs.fromEvent(document, 'click')
                .pipe(
                    rxjs.operators.map((ev) => ev.clientX),
                    rxjs.operators.debounceTime(2000)
                )
        </code></pre>
    <!--vcnl9snmT7PPqvOd0n-->
    <iframe src="https://giphy.com/embed/WwBRM6pADlyXPwri2T" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>It's like delay, but passes only the most recent value from each burst of emissions</blockquote>
</section>
<section>
    <h2>Debounce Operator</h2>
    <!-- <p>Emits a value from the source Observable only after a particular time span determined by another Observable has passed without another source emission</p> -->
    <pre><code class="js"  data-trim contenteditable>
            const clicks$ = rxjs.fromEvent(document, 'click')
            clicks$
                .pipe(
                    rxjs.operators.debounce(() => rxjs.interval(1000)),
                    rxjs.operators.map((ev)=> ev.clientX)
                )
        </code></pre>
    <iframe src="https://giphy.com/embed/42ylm7n9CgbcyGlEEP" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>It's like debounceTime, but the time span of emission silence is determined by a second Observable</blockquote>
</section>
<section>
    <h2>ThrottleTime Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
                rxjs.of(1, 10)
                    .pipe(
                        rxjs.operators.throttleTime(2000)
                    )
                // Synchronous  values with a complete() signal event
                // bring about receive immediately the first event and no more
        </code></pre>
    <img src="images/throttleTime.png" width="400" style="border: none;" alt="ThrottleTime synchronous value marble diagram"
    />
    <pre><code class="js"  data-trim contenteditable>
                rxjs.fromEvent(document, 'click')
                    .pipe(
                        rxjs.operators.map((ev) => ev.clientX),
                        rxjs.operators.throttleTime(2000)
                    )
            </code></pre>
    <iframe src="https://giphy.com/embed/kVh2Bn17mj9CX9bM2y" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Lets a value pass, then ignores source values for the next duration milliseconds</blockquote>
</section>
<section>
    <h2>Throttle Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
        //emit value every 1 second
        const source$ = rxjs.interval(1000)
        //throttle for 2 seconds, emit latest value
        source$.pipe(rxjs.operators.throttle(val => rxjs.timer(2000)))
    </code></pre>
    <iframe src="https://giphy.com/embed/fRaBQ1XAxStfrFevl5" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>It's like throttleTime, but the silencing duration is determined by a second Observable</blockquote>
</section>
<section>
    <h4>Distinct Operator</h4>

    <pre><code class="js"  data-trim contenteditable>
        rxjs.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3)
            .pipe(
                rxjs.operators.distinct() // 1, 2, 3, 4
            )
    </code></pre>

    <img src="images/distinct.png" width="400" style="border: none;" alt="Distinct synchronous value marble diagram" />

    <blockquote>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous
        items
    </blockquote>
    <aside class="notes">
        <pre><code class="js" style="font-size: 0.75em" data-trim contenteditable>
            interface Person {
                age: number,
                name: string
            }

            rxjs.of< Person >(
                { age: 4, name: 'Foo'},
                { age: 7, name: 'Bar'},
                { age: 5, name: 'Foo'})
                .pipe(rxjs.operators.distinct((p: Person) => p.name))
                .subscribe(x => console.log(x));

            // displays:
            // { age: 4, name: 'Foo' }
            // { age: 7, name: 'Bar' }
        </code></pre>
    </aside>
</section>
<section>
    <h4>DistinctUntilChanged Operator</h4>

    <pre><code class="js"  data-trim contenteditable>
        rxjs.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3)
            .pipe(
                rxjs.operators.distinctUntilChanged() // 1, 2, 1, 2, 3, 4, 3
            )
    </code></pre>

    <img src="images/distinctUntilChanged.png" width="400" style="border: none;" alt="DistinctUntilChanged synchronous value marble diagram"
    />
    <blockquote>Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the
        previous item
    </blockquote>
</section>
<section>
    <h4>Take Operator</h4>

    <pre><code class="js" data-trim contenteditable>
        rxjs.interval(1000)
            .pipe(
                rxjs.operators.take(5)
            )
    </code></pre>
    <iframe src="https://giphy.com/embed/ftdjQXPCukeQuWOX6U" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Takes the first count values from the source, then completes</blockquote>
</section>
<section>
    <h4>TakeLast Operator</h4>

    <pre><code class="js" data-trim contenteditable>
        rxjs.range(1, 100)
            .pipe(
                rxjs.operators.takeLast(3)
            )
    </code></pre>
    <img src="images/takeLast.png" width="400" style="border: none;" alt="takeLast synchronous value marble diagram" />
    <blockquote>Remembers the latest count values, then emits those only when the source completes</blockquote>
</section>
<section>
    <h4>TakeUntil Operator</h4>

    <pre><code class="js"  data-trim contenteditable>
        rxjs.interval(1000)
            .pipe(
                rxjs.operators.takeUntil(rxjs.timer(5000))
            )
    </code></pre>
    <iframe src="https://giphy.com/embed/d2rEP18hG7x8lTc6BD" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Lets values pass until a second Observable, notifier, emits something. Then, it completes</blockquote>
</section>
<section>
    <h4>TakeWhile Operator</h4>
    <pre><code class="js"  data-trim contenteditable>
        rxjs.interval(1000)
            .pipe(
                rxjs.operators.takeWhile(value => value < 3)
            )
    </code></pre>
    <iframe src="https://giphy.com/embed/5zh3jlVuUkcoApf9FP" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote>Takes values from the source only while they pass the condition given. When the first value does not satisfy, it completes
    </blockquote>
</section>
<section>
    <h4>Other Filtering Operators</h4>
    <ul style="font-size: 0.75em">
        <li>first([predicateFunction(), projectionFunction(), defaultValue])
            <a href="//jsfiddle.net/btroncone/owx2jdg1/3/" target="_blank">here</a>
        </li>
        <li>last ([predicateFunction(), projectionFunction(), defaultValue])
            <a href="//jsfiddle.net/btroncone/L7fbx3vp/" target="_blank">here</a>
        </li>
        <br>
        <li>skip()
            <a href="//jsfiddle.net/btroncone/ar1eqbya/" target="_blank">here</a>
        </li>
        <li>skipUntil()
            <a href="//jsfiddle.net/btroncone/xLu8nf77/" target="_blank">here</a>
        </li>
        <li>skipWhile()
            <a href="//jsfiddle.net/btroncone/3ymfxb09/" target="_blank">here</a>
        </li>
        <br>
        <li>auditTime(periodNumber) => when it sees a source values, it ignores that plus the next ones for duration milliseconds,
            and then it emits the most recent value from the source</li>
        <li>audit(predicateObservable) => it's like auditTime, but the silencing duration is determined by a second Observable</li>
        <li>ignoreElements() => ignores all items emitted by the source Observable and only passes calls of complete or error</li>
        <li>sample(predicateObservable) => last emitted value</li>
        <li>sampleTime(periodNumber) => last emitted value at periodic time interval</li>
        <li>single(predicateFunction) => return value if one match otherwise (more value matched) error</li>
    </ul>
</section>
