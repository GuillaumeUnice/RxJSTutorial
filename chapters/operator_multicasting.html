<section>
    <h2>Multicasting Operators</h2>
    <ul>
        <li>Share</li>
        <li>ShareReplay</li>
        <br>
        <li>Publish Operator</li>
        <li>PublishReplay Operator</li>
        <li>publishLast Operator</li>
        <li>Multicast Operator</li>
    </ul>
</section>

<section>
        <h2>Cold vs Hot</h2>
        <table>
                <thead>
                    <tr style="color: rgb(233, 70, 70)">
                        <th></th>
                        <th>COLD</th>
                        <th>HOT</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="color: rgb(70, 81, 233)">Manage Unsubscription</td>
                        <td>True</td>
                        <td>False (our responsability) liability => memory leak Only concern manual Multicasting operator not fromEvent or share()</td>
                    </tr>
                </tbody>
            </table>
    </section>
<section>
    <h2>Publish Operator</h2>
    <pre><code class="js"  data-trim contenteditable>
            Rx.Observable.fromEvent(document, 'click')
            .map(ev => ev.clientX)
        </code></pre>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        const source$ = Rx.Observable.interval(1000)
            .take(10)
            const published$ = source$.publish()
            published$.subscribe(createObserver('SubA'))
            published$.subscribe(createObserver('SubB'))

            // ...
            published$.connect() //Can be invoked at any point after the call to publish() => in order to build the underlying subscription
    </code></pre>

    <p>Publish return an ConnectableObservable</p>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        interface ConnectableObservable< T > extends Observable< T > {
            connect() : Subscription
            refCount(): Observable< T >
        }
    </code></pre>
    <blockquote>Like a share Operator not garbage collected &amp; emits data after a call to connect()</blockquote>
    <!--
        -The connect() method returns a Subscription instance that represents the shared underlying subscription. Unsubscribing from it will result in both subscribers no longer receiving any events.
        -The refCount() method is named after the garbage collection concept known as ref counting, or reference counting. The point is that it returns an observable sequence that stays connected to the source as long as thereâ€™s a least one active subscription. Does this sound familiar? It should because the share() operator we discussed a moment ago is little more than an alias for publish().refCount()
    -->
</section>
<section>
    <h2>PublishReplay Operator</h2>
    <p>This operator uses several parameters to determine the characteristics of a buffer to maintain</p>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
        </code></pre>
    <iframe src="https://giphy.com/embed/" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote></blockquote>
</section>
<section>
    <h2>Share Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
            </code></pre>
    <iframe src="https://giphy.com/embed/" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote></blockquote>
</section>
<section>
    <h2>ShareReplay Operator</h2>
    <pre style="font-size: 0.5em"><code class="js"  data-trim contenteditable>
                </code></pre>
    <iframe src="https://giphy.com/embed/" width="400" height="100%" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <blockquote></blockquote>
</section>
<section>
    <h2>Other Multicasting Operators</h2>

    cache publishBehavior publishLast

</section>