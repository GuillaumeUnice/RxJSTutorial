<section>
    <h2>Cold &amp; Hot Observable</h2>
    <!--
Analogies

It helps to think of cold and hot Observables as movies or performances that one can watch ("subscribe").

Cold Observables: movies.
Hot Observables: live performances.
Hot Observables replayed: live performances recorded on video.
Whenever you watch a movie, your run of the movie is independent of anyone else's run, even though all movie watchers see the same effects.
On the other hand, a live performance is shared to multiple viewers.
 If you arrive late to a live performance, you will simply miss some of it.

 However, if it was recorded on video (in RxJS this would happen with a BehaviorSubject or a ReplaySubject), you can watch a "movie" of the live performance. A .publish().refCount() live performance is one where the artists quit playing when no one is watching, and start playing again when there is at least one person in the audience.

    -->

    <table>
        <thead>
            <tr style="color: rgb(233, 70, 70)">
                <th></th>
                <th>Single Value</th>
                <th>Multiple Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="color: rgb(70, 81, 233)">Synchronous</td>
                <td>COLD Observable</td>
                <td>COLD Observable</td>
            </tr>
            <tr>
                <td style="color: rgb(70, 81, 233)">Asynchronous</td>
                <td>COLD Observable (Ajax) | HOT Observable (Promise)</td>
                <td>HOT Observable</td>
            </tr>
        </tbody>
    </table>
    <p>We can categorize by native type behind but there is also the possibility to heat up a Cold Observable</p>
    <aside class="notes">
        Whether an observable is hot or cold is partly related to the type of source that it’s wrapping
    </aside>
</section>
<section>
    <h2>Cold Observable</h2>

    <ul>
        <li>Lazy Observable</li>
        <li>Pure Function => referential transparency</li>
        <li>Independent subscription</li>
    </ul>
    <br>
    <img src="images/cold_hot/cold_observable.png" width="400" style="border: none;" alt="Cold Observable schema" />
    <aside class="notes">
        - These resources are known as passive in the sense that their declaration is independent of their execution. This also means
        that these observables are truly lazy in their creation and execution - Being cold means that each new subscription
        is creating a new independent stream with a new starting point for that stream. - When creating a cold observable,you’re
        actually creating a plan or recipe to be executed later repeatedly, top to bottom => Result no matter at what point
        there is a n Observer subscription at a cold Observable, each Observer independently will observe same event (if
        you respect the purity concept) => determinitic
        <br> No data shared so purest solution
        <!--With cold observables, all subscribers, no matter at what point the subscription occurred, will observe the same events.-->
    </aside>

    <blockquote>Like a synchronous code behaviour</blockquote>
</section>
<section>
    <h2>Hot Observable</h2>
    <!--hot observables tend to receive only the events that are emitted after the subscription is created
    Keep Lazy
    emits the ongoing sequence of events from the point of subscription and not from the beginning

which means it won’t reenact all the messages emitted upon subscription but merely begin pushing any that occur thereafter
-->
    <ul>
        <li>Keep Lazy Observable data are ignored without subscription</li>
        <li>a hot observable shares the same subscription to all observers => Dependent subscription</li>
    </ul>
    <img src="images/cold_hot/hot_observable.png" width="400" style="border: none;" alt="Cold Observable schema" />

    <!--Hot observables are those that produce events regardless of the presence of subscribers
    you-snooze-you-lose policy => which means you can’t replay the contents of a hot observable by resubscribing to it
    -->
    <blockquote>Like a asynchronous code behaviour</blockquote>

    <!-- In general, it’s better to use cold observables wherever possible because they’re inher-
ently stateless. This means that each subscription is independent of every other sub-
scription, so there’s less shared state to worry about, from an internal RxJS
perspective, because you know a new stream is starting on every subscription.
=>As an added complication, time dependencies aren’t necessarily deterministic HOT are not purely pure (no pun intended) from an FP perspective
But when you are inside our Observable we can consider from an RxJS perspective all kind of Observables keep pure!

-->
    <aside class="notes">
        - Hot observables tend to receive only the events that are emitted after the subscription is created - New Subscription receive
        ongoing sequence => no reenact/replay events already emitted just push event occured after subscription - Hot Observables
        produce events regardless presence of subscribers => you-snooze-you-lose policy => which means you can’t replay the
        contents of a hot observable by resubscribing to it - Cold stateless more FP compliant - Hot Observable not deterministic
        so not pure from purist FP perspective => From RxJS perspective inside value inside Observable will produce same
        result so we can consider Hot keep pure!
    </aside>
</section>

<section>
    <h2>Replay vs Resubscribe</h2>

    <p>Observable replay the pipeline can be considered like Hot events are buffered internally</p>
    <p>Promise Hot usual caveat:
        <a href="//jsfiddle.net/Echyzen/qp9fgvc0/" target="_blank">Here</a>
    </p>
    <p>
        => Solution consist to wrap the [Fetch|XHR] in a higher order Observable:
            <a href="//jsfiddle.net/Echyzen/na0agmu8/1/" target="_blank">Here</a>
    </p>

    <aside class="notes">
        the Promise is immutable/single-value and only replay so emit the same previous first result without recompute the pipeline
        <br>
        <br> - Here a retry strategy is utterly useless
        <br> => Solution consist to wrap the Fetch in another Observable which is by definition retriable
        <br>
        <a href="//jsfiddle.net/Echyzen/4zanwjut/" target="_blank">Solution Here</a>
    </aside>
</section>
<section>
    <h2>What's the temperature today?</h2>
    <p>Temperature depends on:</p>
    <ul>
        <li>The data source which by design are cold or hot</li>
        <li>The context where data come from inside (cold) or outside (hot) Observable context</li>
    </ul>
    <p>=> Control the temperature by wrapping or not the data source</p>

    <blockquote>COLD is when your observable creates the producer.
        <br> HOT is when your observable closes over the producer.
        <br>
        <span style="position: absolute; right: 0; bottom: -20px; font-size: 0.5em">Ben Lesh on Medium</span>
    </blockquote>

    <aside class="notes">
        In practice, when the producer resource is expensive to create, such as a remote HTTP call or a WebSocket, then sharing it
        is a smart thing to do.
        <br> Let’s examine how to heat up observables to accomplish this. depends on how to place the activation of the producer
        resource inside or outside the observable context

        <br>
        <br> COLD:
        <br> A new Producer instance for each subscription => Unicast communication: 1 Producer => 1 Observer HOT:
        <br> In this case, the lifecycle of the event emitter source is independent of that of the observable => Multicast communication:
        1 Producer => X Observer
    </aside>
</section>
<section data-background-image="./images/cold_hot/fresh_wallpaper.jpg">
    <h2>Cool Down Hot Observable</h2>
    <p>Avoid the side effect by wrapping and instantiating a new [Promise|WebSocket] inside the "Producer" function</p>
    <a href="//jsfiddle.net/Echyzen/dztkw6x1/" target="_blank">Here</a>

</section>

<section data-background-image="./images/cold_hot/warmth_wallpaper.jpg">
    <h2>Heat Up Cold Observable</h2>
    <p>
        Outside the data source from the Producer.
        <br> Decoupled the subscription from the activation of the event source
    </p>

    <!--
        To make a cold observables hot, you need to focus on how they emit data and how subscribers access this data
    => you must move the source of events (stock ticks) away from the observable pipeline
    TODO: read https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html#caveat-http-with-observables

    Appendix in Angular Http Call are cold which means not like the fromPromise() behaviour
-->

    <pre><code class="js"  data-trim contenteditable>
        const source$ = Rx.Observable.timer(0, 1000)
            .take(10)
            .do(num => {
                console.log(`Running some code with ${num}`);
            });
            // Here stream become hot-by-operator
            const shared$ = source$.share();

            shared$.subscribe(myObserver('ObsA'));
            shared$.subscribe(myObserver('ObsB'));

            const myObserver = (name) => {
                return {
                    next: x => {
                        console.log(`Next: ${name} ${x}`)
                    },
                    error: err => {
                        console.log(`Error: ${err}`)
                    },
                    complete: () => {
                        console.log('Completed')
                    }
                }
            }
    </code></pre>

    <aside class="notes">
        -The big difference here is that you’ve decoupled the subscription from the activation of the event source
        <br> - Because of this decoupling, the observable is also removed from the lifecycle of the event source (that is, start()
        and stop() ), just like with WebSockets earlier. Thus, when all subscribers unsubscribe, the event emitter will continue
        to send data
        <br> => it’s just that no one is there to listen
        <br>
        <br> Do Not use share with synchronous data source:
        <br> In basic terms, subscribing to a synchronous source like an array will execute and complete before the second subscribe
        statement is even reached
        <br> => No interest
        <pre><code class="js"  data-trim contenteditable>
            const source$ = Rx.Observable.from([1,2,3,4])
                .filter(isEven)
                .map(x => x * x)
                .share()
            source$.subscribe(x => console.log(`Stream 1 ${x}`))
            source$.subscribe(x => console.log(`Stream 2 ${x}`))
        </code></pre>
    </aside>
</section>
<section>
    <h2>Warm Observable vs Hot Observable</h2>

    <aside class="notes">
        Observables share subscriptions nammed hot !== Cold Observable
        <br> Warm Observable start emitting events only after the first subscription (cold observables characteristic) + share
        their data to all subscribers (hot observables characteristic)
        </code>
        </pre>
    </aside>
</section>
<section>
    <h2>Unsubscription liability?</h2>
    <table>
        <thead>
            <tr style="color: rgb(233, 70, 70)">
                <th></th>
                <th>COLD</th>
                <th>WARM</th>
                <th>HOT</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="color: rgb(70, 81, 233)">RxJS liability?</td>
                <td>True</td>
                <td>True <br><span style="font-size: 0.5em;">(share, fromEvent)</span></td>
                <td>False <br><span style="font-size: 0.5em;">=> memory leak Only concern manual Multicasting operator (publish)</span></td>
            </tr>
        </tbody>
    </table>
</section>
